const rocketWidth = 15;
const rocketHeight = 60;

const rocketProps = [
    // {a: 0, r: rocketHeight / 2},
    // {a: Math.PI / 2, r: rocketHeight / 2},
    // {a: -Math.PI / 2, r: rocketHeight / 2},
    // {a: Math.PI / 10, r: rocketHeight / 2},
    // {a: Math.PI * 9 / 10, r: rocketHeight / 2},
    {a: Math.PI / 2, r: rocketHeight / 2},
    {a: Math.PI / 2 + Math.PI / 4, r: rocketHeight / 2},
    {a: Math.PI / 2 - Math.PI / 4, r: rocketHeight / 2},
];

const rocketAngularInertia = 5;
const rocketMass = 0.1;


class Rocket {
    constructor (startX, startY, startAngle, propAngles, activations) {
        this.x = startX;
        this.y = startY;

        this.vel = {
            x: 0,
            y: 0,
        };
        this.acc = {
            x: 0,
            y: 0,
        }

        this.score = 0;

        this.speciesID = 0;

        this.color = "WHITE"

        this.ang = startAngle;
        this.angVel = 0;
        this.angAcc = 0;

        // Propellers
        this.props = [];
        this.initProps(propAngles);
        
        // Activations timings of the propellers
        this.activations = activations;

        this.freeze = false;
    }

    reset(startX, startY, startAngle) {
        this.x = startX;
        this.y = startY;

        this.vel = {
            x: 0,
            y: 0,
        };
        this.acc = {
            x: 0,
            y: 0,
        }

        this.score = 0;

        this.ang = startAngle;
        this.angVel = 0;
        this.angAcc = 0;
    }

    // Generate propellers with the right angles
    initProps(propAngles) {
        let i = 0;
        for (let prop of rocketProps) {
            this.props.push(new Propeller(Math.cos(prop.a) * prop.r, Math.sin(prop.a) * prop.r, propAngles[i]));
            i++;
        }

        this.calculateSpeciesID();

    }

    // Draw the rockets
    draw() {
        rectMode(CENTER);
        stroke(0);
        strokeWeight(1);
        fill(this.color);
        push();

        translate(this.x, this.y);
        rotate(this.ang);
        rect(0, 0, rocketWidth, rocketHeight);

        for (let prop of this.props) {
            prop.draw();
        }
        
        pop();
    }

    // Update the physics
    update(frame) {
        // If the rocket reached the end don't move it
        if (this.freeze) {
            return;
        }

        // Reset the accelerations for the new computing cycle
        this.acc.x = 0;
        this.acc.y = 0;
        this.angAcc = 0;

        // Calculate the acceleration given by every propeller
        for (let i = 0; i < this.props.length; i++) {
            let p = this.props[i];

            // Check if the current propeller is active
            p.active = this.activations[frame];
            if (!p.active) {
                continue;
            }

            // Get the force vector generated by this propeller (depends on the current rocket angle)
            let f = p.computeForce(this.ang);

            // Get the application point of the force given by the propeller
            let appPoint = {
                x: Math.cos(this.ang + rocketProps[i].a) * rocketProps[i].r,
                y: Math.sin(this.ang + rocketProps[i].a) * rocketProps[i].r,
            }

            let pj_c = (appPoint.x * f.x + appPoint.y * f.y) /
                 ((appPoint.x ** 2 + appPoint.y ** 2));

            let par = {
                x: appPoint.x * pj_c, 
                y: appPoint.y * pj_c, 
            }

            let rotAcc = {
                x: f.x - par.x,
                y: f.y - par.y,
            }

            // Compute the scalar product beetween the force that 
            // rotates the rocket and the direction vector of the rockets to check if the new angle (alpha)
            // should be in a clockwise or anti-clockwise direction
            let sc = rotAcc.x * Math.cos(this.ang) + rotAcc.y * Math.sin(this.ang);
            let alpha;
            if (sc != 0) {
                alpha = (sc > 0 ? -1 : 1) * Math.sqrt(rotAcc.x ** 2 + rotAcc.y ** 2) / rocketAngularInertia;
            } else {
                alpha = Math.sqrt(rotAcc.x ** 2 + rotAcc.y ** 2) / rocketAngularInertia;
            }

            this.angAcc += alpha;

            this.acc.x += f.x / rocketMass;
            this.acc.y += f.y / rocketMass;
        }
        // Euler integration 

        this.vel.x += this.acc.x * deltaTime / 1000;
        this.vel.y += this.acc.y  * deltaTime / 1000;
        
        this.angVel += this.angAcc * deltaTime / 1000;
        this.ang += this.angVel * deltaTime / 1000;

        this.x += this.vel.x * deltaTime / 1000;
        this.y += this.vel.y * deltaTime / 1000;

    }

    // Score function
    updateScore(target, frame) {
        if (this.freeze) {
            return; 
        }

        // Distance from the target
        let squareDist = (target.x - this.x) ** 2 + (target.y - this.y) ** 2; 

        // Score calculated in this frame (depends on the time and the distance to the target)
        let s = 1000 * (rocketsNumber / (frame + 1)) / (squareDist);

        // Update the score if it is better
        if (s > this.score) {
            this.score = s;
        }

        // Stop the rocket if reaches the target
        if (squareDist < 400) {
            this.freeze = true;
            this.score *= 1.1;
        }
    }


    // Generate a new rocket, in this case just return a clone
    mutate(start, propAngleMutationRate, activationsMutationRate, otherRockets) {
        this.reset(start.x, start.y, 0);
        return this;
    }

    calculateSpeciesID() {
        this.speciesID = Math.floor(clampToInt(this.props[0].ang) + clampToInt(this.props[1].ang) * 1000 + clampToInt(this.props[2].ang) * 1000000);
        this.color = color(this.getID_A(), this.getID_B(), this.getID_C());
    }

    speciesDistance(other) {
        return ((other.getID_A() - this.getID_A()) ** 2 + 
            (other.getID_B() - this.getID_B()) ** 2 + 
            (other.getID_C() - this.getID_C()) ** 2) / 3000000;
    }

    getID_A() {
        return this.speciesID % 1000;
    }

    getID_B() {
        return (this.speciesID % 1000000) / 1000;
    }

    getID_C() {
        return this.speciesID / 1000000;
    }
}

function clampToInt(n) {
    return 255 - ((Math.floor(n * 32)) % 255);
}


    // mutate(start, pAM, aMR, other) {
    //     let new_rocket = new Rocket(start.x, start.y, 0);

    //     let propsAngs = [];

    //     for (let i = 0; i < rocketProps.length; i++) {
    //         let newPropAng = (Math.random() > 0.5 ? this.props[i].ang : other.props[i].ang);
    //         newPropAng += (Math.random() > pAM ? (Math.random() - 0.5) * 0.5 : 0);
    //         propsAngs.push(newPropAng);
    //     } 

    //     let act = [];

    //     for (let i = 0; i < rocketProps.length; i++) {
    //         let splitPoint = Math.floor(Math.random() * simFrames);
    //         act[i] = [];
    //         for (let j = 0; j < simFrames; j++) {
    //             act[i][j] = (j < splitPoint ? this.activations[i][j] : other.activations[i][j]);
    //             act[i][j] = (Math.random() > aMR ? act[i][j] : Math.random() > 0.5);
    //         }
    //     }
        
    //     new_rocket.initProps(propsAngs, act);
    //     return new_rocket;
    // }


